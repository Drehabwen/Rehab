# è¯­éŸ³è½¬ç—…ä¾‹åŠ©æ‰‹ - å°ç¨‹åºé›†æˆæŒ‡å—

## ğŸ“± å°ç¨‹åºé›†æˆ

æœ¬æŒ‡å—å°†å¸®åŠ©æ‚¨å°†è¯­éŸ³è½¬ç—…ä¾‹åŠ©æ‰‹ API é›†æˆåˆ°å¾®ä¿¡å°ç¨‹åºä¸­ã€‚

---

## ğŸš€ å¿«é€Ÿå¼€å§‹

### 1. å‡†å¤‡å·¥ä½œ

#### 1.1 é…ç½®æœåŠ¡å™¨åŸŸå

åœ¨å¾®ä¿¡å…¬ä¼—å¹³å°é…ç½®æœåŠ¡å™¨åŸŸåï¼š

1. ç™»å½• [å¾®ä¿¡å…¬ä¼—å¹³å°](https://mp.weixin.qq.com/)
2. è¿›å…¥"å¼€å‘" -> "å¼€å‘ç®¡ç†" -> "å¼€å‘è®¾ç½®"
3. åœ¨"æœåŠ¡å™¨åŸŸå"ä¸­æ·»åŠ ï¼š
   - request åˆæ³•åŸŸåï¼š`https://your-domain.com`
   - uploadFile åˆæ³•åŸŸåï¼š`https://your-domain.com`

**æ³¨æ„**ï¼šå¿…é¡»ä½¿ç”¨ HTTPS åè®®

#### 1.2 è·å– API æœåŠ¡åœ°å€

ç¡®è®¤æ‚¨çš„ API æœåŠ¡åœ°å€ï¼š
- æœ¬åœ°å¼€å‘ï¼š`http://localhost:5000`
- ç”Ÿäº§ç¯å¢ƒï¼š`https://your-domain.com`

---

## ğŸ“¦ å®‰è£…ä¾èµ–

å°ç¨‹åºæ— éœ€å®‰è£…é¢å¤–ä¾èµ–ï¼Œç›´æ¥ä½¿ç”¨å¾®ä¿¡å°ç¨‹åºåŸç”Ÿ API å³å¯ã€‚

---

## ğŸ”§ é…ç½® API åŸºç¡€ä¿¡æ¯

### åˆ›å»º API é…ç½®æ–‡ä»¶

åœ¨é¡¹ç›®ä¸­åˆ›å»º `config/api.js`ï¼š

```javascript
// config/api.js
module.exports = {
  // API åŸºç¡€åœ°å€
  baseURL: 'https://your-domain.com',
  
  // è¶…æ—¶æ—¶é—´ï¼ˆæ¯«ç§’ï¼‰
  timeout: 30000,
  
  // é‡è¯•æ¬¡æ•°
  retryCount: 3
}
```

---

## ğŸ“¡ API å°è£…

### åˆ›å»º API è¯·æ±‚å·¥å…·

åœ¨é¡¹ç›®ä¸­åˆ›å»º `utils/api.js`ï¼š

```javascript
// utils/api.js
const config = require('../config/api.js')

class API {
  constructor() {
    this.baseURL = config.baseURL
    this.timeout = config.timeout
    this.retryCount = config.retryCount
  }

  request(options) {
    return new Promise((resolve, reject) => {
      const { url, method = 'GET', data = {}, header = {} } = options
      
      wx.request({
        url: `${this.baseURL}${url}`,
        method,
        data,
        header: {
          'content-type': 'application/json',
          ...header
        },
        timeout: this.timeout,
        success: (res) => {
          if (res.statusCode === 200) {
            if (res.data.status === 'success') {
              resolve(res.data.data)
            } else {
              reject(new Error(res.data.message || 'è¯·æ±‚å¤±è´¥'))
            }
          } else {
            reject(new Error(`HTTP ${res.statusCode}`))
          }
        },
        fail: (error) => {
          reject(error)
        }
      })
    })
  }

  async requestWithRetry(options, retryCount = 0) {
    try {
      return await this.request(options)
    } catch (error) {
      if (retryCount < this.retryCount) {
        console.log(`è¯·æ±‚å¤±è´¥ï¼Œé‡è¯• ${retryCount + 1}/${this.retryCount}`)
        await this.sleep(1000 * (retryCount + 1))
        return this.requestWithRetry(options, retryCount + 1)
      }
      throw error
    }
  }

  sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms))
  }
}

module.exports = new API()
```

---

## ğŸ™ï¸ è¯­éŸ³å½•åˆ¶ä¸è½¬å½•

### åˆ›å»ºå½•éŸ³å·¥å…·

åœ¨é¡¹ç›®ä¸­åˆ›å»º `utils/recorder.js`ï¼š

```javascript
// utils/recorder.js
const api = require('./api.js')

class Recorder {
  constructor() {
    this.recorderManager = null
    this.tempFilePath = null
  }

  init() {
    this.recorderManager = wx.getRecorderManager()
    
    this.recorderManager.onStop((res) => {
      this.tempFilePath = res.tempFilePath
      console.log('å½•éŸ³å®Œæˆ:', res.tempFilePath)
    })
    
    this.recorderManager.onError((error) => {
      console.error('å½•éŸ³é”™è¯¯:', error)
    })
  }

  start(options = {}) {
    const defaultOptions = {
      duration: 60000,
      sampleRate: 16000,
      numberOfChannels: 1,
      encodeBitRate: 48000,
      format: 'wav'
    }
    
    this.recorderManager.start({ ...defaultOptions, ...options })
  }

  stop() {
    return new Promise((resolve, reject) => {
      this.recorderManager.onStop((res) => {
        this.tempFilePath = res.tempFilePath
        resolve(res.tempFilePath)
      })
      
      this.recorderManager.onError((error) => {
        reject(error)
      })
      
      this.recorderManager.stop()
    })
  }

  async transcribe(audioPath) {
    try {
      const fileSystemManager = wx.getFileSystemManager()
      const audioData = fileSystemManager.readFileSync(audioPath, 'base64')
      
      const result = await api.requestWithRetry({
        url: '/api/transcribe',
        method: 'POST',
        data: {
          audio_data: audioData,
          format: 'wav'
        }
      })
      
      return result.transcript
    } catch (error) {
      console.error('è½¬å½•å¤±è´¥:', error)
      throw error
    }
  }

  async recordAndTranscribe(duration = 60000) {
    try {
      this.start({ duration })
      wx.showToast({
        title: 'å½•éŸ³ä¸­...',
        icon: 'none'
      })
      
      const audioPath = await this.stop()
      wx.hideToast()
      
      wx.showLoading({ title: 'è½¬å½•ä¸­...' })
      const transcript = await this.transcribe(audioPath)
      wx.hideLoading()
      
      return transcript
    } catch (error) {
      wx.hideToast()
      wx.hideLoading()
      wx.showToast({
        title: 'è½¬å½•å¤±è´¥',
        icon: 'none'
      })
      throw error
    }
  }
}

module.exports = new Recorder()
```

---

## ğŸ“‹ ç—…ä¾‹ç®¡ç†å·¥å…·

### åˆ›å»ºç—…ä¾‹ç®¡ç†å·¥å…·

åœ¨é¡¹ç›®ä¸­åˆ›å»º `utils/case.js`ï¼š

```javascript
// utils/case.js
const api = require('./api.js')

class CaseManager {
  async structureCase(transcript, separateSpeakers = true) {
    try {
      const result = await api.requestWithRetry({
        url: '/api/structure',
        method: 'POST',
        data: {
          transcript,
          separate_speakers: separateSpeakers
        }
      })
      
      return result.structured_case
    } catch (error) {
      console.error('ç—…ä¾‹ç»“æ„åŒ–å¤±è´¥:', error)
      throw error
    }
  }

  async generateMedicalRecord(structuredCase, patientInfo, doctorInfo) {
    try {
      const result = await api.requestWithRetry({
        url: '/api/generate',
        method: 'POST',
        data: {
          structured_case: structuredCase,
          patient_info: patientInfo,
          doctor_info: doctorInfo
        }
      })
      
      return result.medical_record
    } catch (error) {
      console.error('ç—…å†ç”Ÿæˆå¤±è´¥:', error)
      throw error
    }
  }

  async exportDocument(medicalRecord, patientInfo, doctorInfo) {
    try {
      const result = await api.requestWithRetry({
        url: '/api/export',
        method: 'POST',
        data: {
          medical_record: medicalRecord,
          patient_info: patientInfo,
          doctor_info: doctorInfo
        }
      })
      
      const base64Data = result.document_base64
      const fileName = result.filename
      const filePath = `${wx.env.USER_DATA_PATH}/${fileName}`
      const buffer = wx.base64ToArrayBuffer(base64Data)
      
      wx.getFileSystemManager().writeFile({
        filePath,
        data: buffer,
        encoding: 'binary'
      })
      
      return filePath
    } catch (error) {
      console.error('æ–‡æ¡£å¯¼å‡ºå¤±è´¥:', error)
      throw error
    }
  }

  async saveCase(caseData) {
    try {
      const result = await api.requestWithRetry({
        url: '/api/case/save',
        method: 'POST',
        data: { case_data: caseData }
      })
      
      return result.case_id
    } catch (error) {
      console.error('ç—…ä¾‹ä¿å­˜å¤±è´¥:', error)
      throw error
    }
  }

  async getCase(caseId) {
    try {
      const result = await api.requestWithRetry({
        url: `/api/case/${caseId}`,
        method: 'GET'
      })
      
      return result
    } catch (error) {
      console.error('è·å–ç—…ä¾‹å¤±è´¥:', error)
      throw error
    }
  }

  async listCases() {
    try {
      const result = await api.requestWithRetry({
        url: '/api/cases',
        method: 'GET'
      })
      
      return result.cases
    } catch (error) {
      console.error('è·å–ç—…ä¾‹åˆ—è¡¨å¤±è´¥:', error)
      throw error
    }
  }

  async deleteCase(caseId) {
    try {
      await api.requestWithRetry({
        url: `/api/case/${caseId}`,
        method: 'DELETE'
      })
      
      return true
    } catch (error) {
      console.error('åˆ é™¤ç—…ä¾‹å¤±è´¥:', error)
      throw error
    }
  }
}

module.exports = new CaseManager()
```

---

## ğŸ“± é¡µé¢å®ç°ç¤ºä¾‹

### å½•éŸ³é¡µé¢

```javascript
// pages/recording/recording.js
const recorder = require('../../utils/recorder.js')
const caseManager = require('../../utils/case.js')

Page({
  data: {
    isRecording: false,
    transcript: '',
    patientInfo: {
      name: '',
      gender: '',
      age: ''
    },
    doctorInfo: {
      name: '',
      department: ''
    }
  },

  onLoad() {
    recorder.init()
  },

  startRecording() {
    this.setData({ isRecording: true })
    recorder.start()
    wx.showToast({
      title: 'å½•éŸ³ä¸­...',
      icon: 'none'
    })
  },

  async stopRecording() {
    try {
      this.setData({ isRecording: false })
      wx.showLoading({ title: 'è½¬å½•ä¸­...' })
      
      const audioPath = await recorder.stop()
      const transcript = await recorder.transcribe(audioPath)
      
      this.setData({ transcript })
      wx.hideLoading()
      
      wx.showToast({
        title: 'è½¬å½•å®Œæˆ',
        icon: 'success'
      })
    } catch (error) {
      wx.hideLoading()
      wx.showToast({
        title: 'è½¬å½•å¤±è´¥',
        icon: 'none'
      })
    }
  },

  async structureCase() {
    try {
      wx.showLoading({ title: 'ç»“æ„åŒ–ä¸­...' })
      
      const structuredCase = await caseManager.structureCase(
        this.data.transcript,
        true
      )
      
      wx.hideLoading()
      
      wx.navigateTo({
        url: `/pages/case/case?structuredCase=${JSON.stringify(structuredCase)}`
      })
    } catch (error) {
      wx.hideLoading()
      wx.showToast({
        title: 'ç»“æ„åŒ–å¤±è´¥',
        icon: 'none'
      })
    }
  }
})
```

### ç—…ä¾‹è¯¦æƒ…é¡µé¢

```javascript
// pages/case/case.js
const caseManager = require('../../utils/case.js')

Page({
  data: {
    structuredCase: {},
    patientInfo: {
      name: '',
      gender: '',
      age: ''
    },
    doctorInfo: {
      name: '',
      department: ''
    },
    medicalRecord: ''
  },

  onLoad(options) {
    if (options.structuredCase) {
      this.setData({ structuredCase: JSON.parse(options.structuredCase) })
    }
  },

  onPatientInfoChange(e) {
    const { field } = e.currentTarget.dataset
    const value = e.detail.value
    this.setData({
      [`patientInfo.${field}`]: value
    })
  },

  onDoctorInfoChange(e) {
    const { field } = e.currentTarget.dataset
    const value = e.detail.value
    this.setData({
      [`doctorInfo.${field}`]: value
    })
  },

  async generateMedicalRecord() {
    try {
      wx.showLoading({ title: 'ç”Ÿæˆä¸­...' })
      
      const medicalRecord = await caseManager.generateMedicalRecord(
        this.data.structuredCase,
        this.data.patientInfo,
        this.data.doctorInfo
      )
      
      this.setData({ medicalRecord })
      wx.hideLoading()
      
      wx.showToast({
        title: 'ç”Ÿæˆå®Œæˆ',
        icon: 'success'
      })
    } catch (error) {
      wx.hideLoading()
      wx.showToast({
        title: 'ç”Ÿæˆå¤±è´¥',
        icon: 'none'
      })
    }
  },

  async exportDocument() {
    try {
      wx.showLoading({ title: 'å¯¼å‡ºä¸­...' })
      
      const docPath = await caseManager.exportDocument(
        this.data.medicalRecord,
        this.data.patientInfo,
        this.data.doctorInfo
      )
      
      wx.hideLoading()
      
      wx.openDocument({
        filePath: docPath,
        success: () => {
          console.log('æ–‡æ¡£æ‰“å¼€æˆåŠŸ')
        }
      })
    } catch (error) {
      wx.hideLoading()
      wx.showToast({
        title: 'å¯¼å‡ºå¤±è´¥',
        icon: 'none'
      })
    }
  },

  async saveCase() {
    try {
      wx.showLoading({ title: 'ä¿å­˜ä¸­...' })
      
      const caseData = {
        patient_info: this.data.patientInfo,
        doctor_info: this.data.doctorInfo,
        structured_case: this.data.structuredCase,
        medical_record: this.data.medicalRecord,
        created_at: new Date().toISOString()
      }
      
      const caseId = await caseManager.saveCase(caseData)
      
      wx.hideLoading()
      
      wx.showToast({
        title: 'ä¿å­˜æˆåŠŸ',
        icon: 'success'
      })
    } catch (error) {
      wx.hideLoading()
      wx.showToast({
        title: 'ä¿å­˜å¤±è´¥',
        icon: 'none'
      })
    }
  }
})
```

### ç—…ä¾‹åˆ—è¡¨é¡µé¢

```javascript
// pages/cases/cases.js
const caseManager = require('../../utils/case.js')

Page({
  data: {
    cases: []
  },

  onLoad() {
    this.loadCases()
  },

  async loadCases() {
    try {
      wx.showLoading({ title: 'åŠ è½½ä¸­...' })
      
      const cases = await caseManager.listCases()
      
      this.setData({ cases })
      wx.hideLoading()
    } catch (error) {
      wx.hideLoading()
      wx.showToast({
        title: 'åŠ è½½å¤±è´¥',
        icon: 'none'
      })
    }
  },

  onRefresh() {
    this.loadCases()
  },

  viewCase(e) {
    const { caseId } = e.currentTarget.dataset
    wx.navigateTo({
      url: `/pages/case-detail/case-detail?caseId=${caseId}`
    })
  },

  async deleteCase(e) {
    const { caseId } = e.currentTarget.dataset
    
    wx.showModal({
      title: 'ç¡®è®¤åˆ é™¤',
      content: 'ç¡®å®šè¦åˆ é™¤è¿™ä¸ªç—…ä¾‹å—ï¼Ÿ',
      success: async (res) => {
        if (res.confirm) {
          try {
            wx.showLoading({ title: 'åˆ é™¤ä¸­...' })
            
            await caseManager.deleteCase(caseId)
            
            wx.hideLoading()
            wx.showToast({
              title: 'åˆ é™¤æˆåŠŸ',
              icon: 'success'
            })
            
            this.loadCases()
          } catch (error) {
            wx.hideLoading()
            wx.showToast({
              title: 'åˆ é™¤å¤±è´¥',
              icon: 'none'
            })
          }
        }
      }
    })
  }
})
```

---

## ğŸ¨ é¡µé¢æ ·å¼ç¤ºä¾‹

### å½•éŸ³é¡µé¢æ ·å¼

```css
/* pages/recording/recording.wxss */
.container {
  padding: 20rpx;
}

.recording-button {
  width: 200rpx;
  height: 200rpx;
  border-radius: 50%;
  background: #07c160;
  color: white;
  display: flex;
  align-items: center;
  justify-content: center;
  margin: 100rpx auto;
  font-size: 32rpx;
}

.recording-button.recording {
  background: #fa5151;
  animation: pulse 1.5s infinite;
}

@keyframes pulse {
  0%, 100% { transform: scale(1); }
  50% { transform: scale(1.1); }
}

.transcript-box {
  margin-top: 40rpx;
  padding: 20rpx;
  background: #f5f5f5;
  border-radius: 10rpx;
  min-height: 200rpx;
}

.action-buttons {
  margin-top: 40rpx;
  display: flex;
  justify-content: space-around;
}

.action-button {
  width: 200rpx;
}
```

---

## ğŸ“ å®Œæ•´å·¥ä½œæµç¨‹ç¤ºä¾‹

### åœ¨ App.js ä¸­åˆå§‹åŒ–

```javascript
// app.js
App({
  onLaunch() {
    console.log('å°ç¨‹åºå¯åŠ¨')
  },
  
  globalData: {
    userInfo: null,
    doctorInfo: {
      name: '',
      department: ''
    }
  }
})
```

### åˆ›å»ºå®Œæ•´çš„å¤„ç†æµç¨‹

```javascript
// utils/workflow.js
const recorder = require('./recorder.js')
const caseManager = require('./case.js')

class Workflow {
  async processMedicalCase(patientInfo, doctorInfo) {
    try {
      // 1. å½•éŸ³
      const audioPath = await this.recordAudio()
      
      // 2. è½¬å½•
      const transcript = await recorder.transcribe(audioPath)
      
      // 3. ç»“æ„åŒ–
      const structuredCase = await caseManager.structureCase(transcript, true)
      
      // 4. ç”Ÿæˆç—…å†
      const medicalRecord = await caseManager.generateMedicalRecord(
        structuredCase,
        patientInfo,
        doctorInfo
      )
      
      // 5. å¯¼å‡ºæ–‡æ¡£
      const docPath = await caseManager.exportDocument(
        medicalRecord,
        patientInfo,
        doctorInfo
      )
      
      // 6. ä¿å­˜ç—…ä¾‹
      const caseData = {
        patient_info: patientInfo,
        doctor_info: doctorInfo,
        transcript,
        structured_case: structuredCase,
        medical_record: medicalRecord,
        created_at: new Date().toISOString()
      }
      const caseId = await caseManager.saveCase(caseData)
      
      return {
        transcript,
        structuredCase,
        medicalRecord,
        docPath,
        caseId
      }
    } catch (error) {
      console.error('å¤„ç†å¤±è´¥:', error)
      throw error
    }
  }

  recordAudio() {
    return new Promise((resolve, reject) => {
      recorder.init()
      recorder.start({ duration: 60000 })
      
      wx.showModal({
        title: 'å½•éŸ³ä¸­',
        content: 'ç‚¹å‡»ç¡®å®šåœæ­¢å½•éŸ³',
        success: async (res) => {
          if (res.confirm) {
            try {
              const audioPath = await recorder.stop()
              resolve(audioPath)
            } catch (error) {
              reject(error)
            }
          }
        }
      })
    })
  }
}

module.exports = new Workflow()
```

---

## âš ï¸ æ³¨æ„äº‹é¡¹

### 1. æƒé™é…ç½®

åœ¨ `app.json` ä¸­é…ç½®å½•éŸ³æƒé™ï¼š

```json
{
  "permission": {
    "scope.record": {
      "desc": "éœ€è¦ä½¿ç”¨æ‚¨çš„éº¦å…‹é£è¿›è¡Œå½•éŸ³"
    }
  }
}
```

### 2. é”™è¯¯å¤„ç†

æ‰€æœ‰ API è°ƒç”¨éƒ½åº”è¯¥åŒ…å«é”™è¯¯å¤„ç†ï¼š

```javascript
try {
  const result = await caseManager.structureCase(transcript)
} catch (error) {
  console.error('é”™è¯¯:', error)
  wx.showToast({
    title: 'æ“ä½œå¤±è´¥',
    icon: 'none'
  })
}
```

### 3. åŠ è½½çŠ¶æ€

åœ¨å¼‚æ­¥æ“ä½œæ—¶æ˜¾ç¤ºåŠ è½½çŠ¶æ€ï¼š

```javascript
wx.showLoading({ title: 'å¤„ç†ä¸­...' })
try {
  await someAsyncOperation()
} finally {
  wx.hideLoading()
}
```

### 4. æ•°æ®éªŒè¯

åœ¨æäº¤æ•°æ®å‰è¿›è¡ŒéªŒè¯ï¼š

```javascript
function validatePatientInfo(patientInfo) {
  if (!patientInfo.name) {
    wx.showToast({ title: 'è¯·è¾“å…¥æ‚£è€…å§“å', icon: 'none' })
    return false
  }
  if (!patientInfo.age) {
    wx.showToast({ title: 'è¯·è¾“å…¥æ‚£è€…å¹´é¾„', icon: 'none' })
    return false
  }
  return true
}
```

---

## ğŸš€ éƒ¨ç½²åˆ°ç”Ÿäº§ç¯å¢ƒ

### 1. ä¿®æ”¹ API åœ°å€

```javascript
// config/api.js
module.exports = {
  baseURL: 'https://your-production-domain.com',
  timeout: 30000,
  retryCount: 3
}
```

### 2. é…ç½® HTTPS

ç¡®ä¿æ‚¨çš„ API æœåŠ¡ä½¿ç”¨ HTTPS åè®®ï¼Œå¹¶åœ¨å¾®ä¿¡å…¬ä¼—å¹³å°é…ç½®åˆæ³•åŸŸåã€‚

### 3. æµ‹è¯•

åœ¨å‘å¸ƒå‰è¿›è¡Œå……åˆ†æµ‹è¯•ï¼š
- åŠŸèƒ½æµ‹è¯•
- æ€§èƒ½æµ‹è¯•
- å…¼å®¹æ€§æµ‹è¯•

---

## ğŸ“ æŠ€æœ¯æ”¯æŒ

å¦‚æœ‰é—®é¢˜ï¼Œè¯·è”ç³»ï¼š
- **GitHub Issues**: https://github.com/your-repo/aisci/issues
- **Email**: support@example.com

---

## ğŸ“„ è®¸å¯è¯

MIT License
