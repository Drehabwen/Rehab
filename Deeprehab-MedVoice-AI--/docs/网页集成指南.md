# è¯­éŸ³è½¬ç—…ä¾‹åŠ©æ‰‹ - ç½‘é¡µé›†æˆæŒ‡å—

## ğŸŒ ç½‘é¡µé›†æˆ

æœ¬æŒ‡å—å°†å¸®åŠ©æ‚¨å°†è¯­éŸ³è½¬ç—…ä¾‹åŠ©æ‰‹ API é›†æˆåˆ°ç½‘é¡µåº”ç”¨ä¸­ã€‚

---

## ğŸš€ å¿«é€Ÿå¼€å§‹

### 1. å‡†å¤‡å·¥ä½œ

#### 1.1 é…ç½® API æœåŠ¡åœ°å€

ç¡®è®¤æ‚¨çš„ API æœåŠ¡åœ°å€ï¼š
- æœ¬åœ°å¼€å‘ï¼š`http://localhost:5000`
- ç”Ÿäº§ç¯å¢ƒï¼š`https://your-domain.com`

#### 1.2 è·¨åŸŸé…ç½®

API æœåŠ¡å·²é…ç½® CORS æ”¯æŒï¼Œå…è®¸è·¨åŸŸè¯·æ±‚ã€‚

---

## ğŸ“¦ å®‰è£…ä¾èµ–

### ä½¿ç”¨ npm

```bash
npm install axios
```

### ä½¿ç”¨ CDN

```html
<script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
```

---

## ğŸ”§ é…ç½® API åŸºç¡€ä¿¡æ¯

### åˆ›å»º API é…ç½®æ–‡ä»¶

```javascript
// config/api.js
export const API_CONFIG = {
  baseURL: 'http://localhost:5000',
  timeout: 30000,
  retryCount: 3
}
```

---

## ğŸ“¡ API å°è£…

### åˆ›å»º API è¯·æ±‚å·¥å…·

```javascript
// utils/api.js
import axios from 'axios'
import { API_CONFIG } from '../config/api.js'

class API {
  constructor() {
    this.client = axios.create({
      baseURL: API_CONFIG.baseURL,
      timeout: API_CONFIG.timeout,
      headers: {
        'Content-Type': 'application/json'
      }
    })
    
    this.client.interceptors.response.use(
      response => response.data,
      error => {
        if (error.response) {
          throw new Error(error.response.data.message || 'è¯·æ±‚å¤±è´¥')
        }
        throw error
      }
    )
  }

  async requestWithRetry(options, retryCount = 0) {
    try {
      const response = await this.client(options)
      if (response.status === 'success') {
        return response.data
      }
      throw new Error(response.message || 'è¯·æ±‚å¤±è´¥')
    } catch (error) {
      if (retryCount < API_CONFIG.retryCount) {
        console.log(`è¯·æ±‚å¤±è´¥ï¼Œé‡è¯• ${retryCount + 1}/${API_CONFIG.retryCount}`)
        await this.sleep(1000 * (retryCount + 1))
        return this.requestWithRetry(options, retryCount + 1)
      }
      throw error
    }
  }

  sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms))
  }

  async transcribe(audioData, format = 'wav') {
    return this.requestWithRetry({
      method: 'POST',
      url: '/api/transcribe',
      data: {
        audio_data: audioData,
        format: format
      }
    })
  }

  async structureCase(transcript, separateSpeakers = true) {
    return this.requestWithRetry({
      method: 'POST',
      url: '/api/structure',
      data: {
        transcript,
        separate_speakers: separateSpeakers
      }
    })
  }

  async generateMedicalRecord(structuredCase, patientInfo, doctorInfo) {
    return this.requestWithRetry({
      method: 'POST',
      url: '/api/generate',
      data: {
        structured_case: structuredCase,
        patient_info: patientInfo,
        doctor_info: doctorInfo
      }
    })
  }

  async exportDocument(medicalRecord, patientInfo, doctorInfo) {
    return this.requestWithRetry({
      method: 'POST',
      url: '/api/export',
      data: {
        medical_record: medicalRecord,
        patient_info: patientInfo,
        doctor_info: doctorInfo
      }
    })
  }

  async saveCase(caseData) {
    return this.requestWithRetry({
      method: 'POST',
      url: '/api/case/save',
      data: { case_data: caseData }
    })
  }

  async getCase(caseId) {
    return this.requestWithRetry({
      method: 'GET',
      url: `/api/case/${caseId}`
    })
  }

  async listCases() {
    return this.requestWithRetry({
      method: 'GET',
      url: '/api/cases'
    })
  }

  async deleteCase(caseId) {
    return this.requestWithRetry({
      method: 'DELETE',
      url: `/api/case/${caseId}`
    })
  }
}

export default new API()
```

---

## ğŸ™ï¸ è¯­éŸ³å½•åˆ¶ä¸è½¬å½•

### åˆ›å»ºå½•éŸ³å·¥å…·

```javascript
// utils/recorder.js
import api from './api.js'

class Recorder {
  constructor() {
    this.mediaRecorder = null
    this.audioChunks = []
    this.isRecording = false
  }

  async init() {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true })
      this.mediaRecorder = new MediaRecorder(stream)
      
      this.mediaRecorder.ondataavailable = (event) => {
        this.audioChunks.push(event.data)
      }
      
      this.mediaRecorder.onstop = async () => {
        const audioBlob = new Blob(this.audioChunks, { type: 'audio/wav' })
        this.audioChunks = []
        return audioBlob
      }
    } catch (error) {
      console.error('åˆå§‹åŒ–å½•éŸ³å¤±è´¥:', error)
      throw error
    }
  }

  start() {
    if (!this.mediaRecorder) {
      throw new Error('å½•éŸ³å™¨æœªåˆå§‹åŒ–')
    }
    
    this.isRecording = true
    this.audioChunks = []
    this.mediaRecorder.start()
  }

  stop() {
    return new Promise((resolve) => {
      if (!this.mediaRecorder) {
        throw new Error('å½•éŸ³å™¨æœªåˆå§‹åŒ–')
      }
      
      this.isRecording = false
      this.mediaRecorder.onstop = async () => {
        const audioBlob = new Blob(this.audioChunks, { type: 'audio/wav' })
        this.audioChunks = []
        resolve(audioBlob)
      }
      
      this.mediaRecorder.stop()
    })
  }

  async transcribe(audioBlob) {
    try {
      const audioData = await this.blobToBase64(audioBlob)
      const result = await api.transcribe(audioData, 'wav')
      return result.transcript
    } catch (error) {
      console.error('è½¬å½•å¤±è´¥:', error)
      throw error
    }
  }

  blobToBase64(blob) {
    return new Promise((resolve, reject) => {
      const reader = new FileReader()
      reader.onloadend = () => resolve(reader.result.split(',')[1])
      reader.onerror = reject
      reader.readAsDataURL(blob)
    })
  }

  async recordAndTranscribe(duration = 60000) {
    try {
      await this.init()
      this.start()
      
      return new Promise((resolve, reject) => {
        setTimeout(async () => {
          try {
            const audioBlob = await this.stop()
            const transcript = await this.transcribe(audioBlob)
            resolve(transcript)
          } catch (error) {
            reject(error)
          }
        }, duration)
      })
    } catch (error) {
      console.error('å½•éŸ³å’Œè½¬å½•å¤±è´¥:', error)
      throw error
    }
  }
}

export default new Recorder()
```

---

## ğŸ“‹ ç—…ä¾‹ç®¡ç†å·¥å…·

### åˆ›å»ºç—…ä¾‹ç®¡ç†å·¥å…·

```javascript
// utils/case.js
import api from './api.js'

class CaseManager {
  async structureCase(transcript, separateSpeakers = true) {
    try {
      const result = await api.structureCase(transcript, separateSpeakers)
      return result.structured_case
    } catch (error) {
      console.error('ç—…ä¾‹ç»“æ„åŒ–å¤±è´¥:', error)
      throw error
    }
  }

  async generateMedicalRecord(structuredCase, patientInfo, doctorInfo) {
    try {
      const result = await api.generateMedicalRecord(
        structuredCase,
        patientInfo,
        doctorInfo
      )
      return result.medical_record
    } catch (error) {
      console.error('ç—…å†ç”Ÿæˆå¤±è´¥:', error)
      throw error
    }
  }

  async exportDocument(medicalRecord, patientInfo, doctorInfo) {
    try {
      const result = await api.exportDocument(
        medicalRecord,
        patientInfo,
        doctorInfo
      )
      
      const base64Data = result.document_base64
      const fileName = result.filename
      
      const binaryString = atob(base64Data)
      const bytes = new Uint8Array(binaryString.length)
      for (let i = 0; i < binaryString.length; i++) {
        bytes[i] = binaryString.charCodeAt(i)
      }
      
      const blob = new Blob([bytes], { type: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document' })
      const url = URL.createObjectURL(blob)
      
      const a = document.createElement('a')
      a.href = url
      a.download = fileName
      document.body.appendChild(a)
      a.click()
      document.body.removeChild(a)
      URL.revokeObjectURL(url)
      
      return fileName
    } catch (error) {
      console.error('æ–‡æ¡£å¯¼å‡ºå¤±è´¥:', error)
      throw error
    }
  }

  async saveCase(caseData) {
    try {
      const result = await api.saveCase(caseData)
      return result.case_id
    } catch (error) {
      console.error('ç—…ä¾‹ä¿å­˜å¤±è´¥:', error)
      throw error
    }
  }

  async getCase(caseId) {
    try {
      const result = await api.getCase(caseId)
      return result
    } catch (error) {
      console.error('è·å–ç—…ä¾‹å¤±è´¥:', error)
      throw error
    }
  }

  async listCases() {
    try {
      const result = await api.listCases()
      return result.cases
    } catch (error) {
      console.error('è·å–ç—…ä¾‹åˆ—è¡¨å¤±è´¥:', error)
      throw error
    }
  }

  async deleteCase(caseId) {
    try {
      await api.deleteCase(caseId)
      return true
    } catch (error) {
      console.error('åˆ é™¤ç—…ä¾‹å¤±è´¥:', error)
      throw error
    }
  }
}

export default new CaseManager()
```

---

## ğŸ“± React ç»„ä»¶ç¤ºä¾‹

### å½•éŸ³ç»„ä»¶

```jsx
// components/Recorder.jsx
import React, { useState, useEffect } from 'react'
import recorder from '../utils/recorder.js'
import caseManager from '../utils/case.js'

function Recorder({ onTranscript }) {
  const [isRecording, setIsRecording] = useState(false)
  const [isTranscribing, setIsTranscribing] = useState(false)
  const [duration, setDuration] = useState(60)

  useEffect(() => {
    recorder.init()
  }, [])

  const handleStartRecording = async () => {
    try {
      setIsRecording(true)
      recorder.start()
    } catch (error) {
      console.error('å¼€å§‹å½•éŸ³å¤±è´¥:', error)
      alert('å¼€å§‹å½•éŸ³å¤±è´¥')
    }
  }

  const handleStopRecording = async () => {
    try {
      setIsRecording(false)
      setIsTranscribing(true)
      
      const audioBlob = await recorder.stop()
      const transcript = await recorder.transcribe(audioBlob)
      
      setIsTranscribing(false)
      onTranscript(transcript)
    } catch (error) {
      console.error('åœæ­¢å½•éŸ³å¤±è´¥:', error)
      setIsTranscribing(false)
      alert('è½¬å½•å¤±è´¥')
    }
  }

  return (
    <div className="recorder">
      <div className="recording-status">
        {isRecording && <div className="recording-indicator">å½•éŸ³ä¸­...</div>}
        {isTranscribing && <div className="transcribing-indicator">è½¬å½•ä¸­...</div>}
      </div>
      
      <div className="recording-controls">
        {!isRecording ? (
          <button 
            className="start-button"
            onClick={handleStartRecording}
            disabled={isTranscribing}
          >
            å¼€å§‹å½•éŸ³
          </button>
        ) : (
          <button 
            className="stop-button"
            onClick={handleStopRecording}
          >
            åœæ­¢å½•éŸ³
          </button>
        )}
      </div>
      
      <div className="duration-control">
        <label>å½•éŸ³æ—¶é•¿ï¼ˆç§’ï¼‰ï¼š</label>
        <input 
          type="number" 
          value={duration} 
          onChange={(e) => setDuration(parseInt(e.target.value))}
          min="10"
          max="300"
        />
      </div>
    </div>
  )
}

export default Recorder
```

### ç—…ä¾‹ç»“æ„åŒ–ç»„ä»¶

```jsx
// components/CaseStructure.jsx
import React, { useState } from 'react'
import caseManager from '../utils/case.js'

function CaseStructure({ transcript, onStructured }) {
  const [isStructuring, setIsStructuring] = useState(false)
  const [structuredCase, setStructuredCase] = useState(null)

  const handleStructureCase = async () => {
    try {
      setIsStructuring(true)
      const result = await caseManager.structureCase(transcript, true)
      setStructuredCase(result)
      onStructured(result)
    } catch (error) {
      console.error('ç»“æ„åŒ–å¤±è´¥:', error)
      alert('ç»“æ„åŒ–å¤±è´¥')
    } finally {
      setIsStructuring(false)
    }
  }

  return (
    <div className="case-structure">
      <div className="structure-controls">
        <button 
          onClick={handleStructureCase}
          disabled={!transcript || isStructuring}
        >
          {isStructuring ? 'ç»“æ„åŒ–ä¸­...' : 'ç»“æ„åŒ–ç—…ä¾‹'}
        </button>
      </div>
      
      {structuredCase && (
        <div className="structured-result">
          <h3>ç»“æ„åŒ–ç»“æœ</h3>
          <div className="field">
            <label>ä¸»è¯‰ï¼š</label>
            <p>{structuredCase.chief_complaint}</p>
          </div>
          <div className="field">
            <label>ç°ç—…å²ï¼š</label>
            <p>{structuredCase.present_illness}</p>
          </div>
          <div className="field">
            <label>æ—¢å¾€å²ï¼š</label>
            <p>{structuredCase.past_history}</p>
          </div>
          <div className="field">
            <label>è¿‡æ•å²ï¼š</label>
            <p>{structuredCase.allergies}</p>
          </div>
          <div className="field">
            <label>ä½“æ ¼æ£€æŸ¥ï¼š</label>
            <p>{structuredCase.physical_exam}</p>
          </div>
          <div className="field">
            <label>è¯Šæ–­ï¼š</label>
            <p>{structuredCase.diagnosis}</p>
          </div>
          <div className="field">
            <label>æ²»ç–—è®¡åˆ’ï¼š</label>
            <p>{structuredCase.treatment_plan}</p>
          </div>
        </div>
      )}
    </div>
  )
}

export default CaseStructure
```

### ç—…ä¾‹ç”Ÿæˆç»„ä»¶

```jsx
// components/MedicalRecordGenerator.jsx
import React, { useState } from 'react'
import caseManager from '../utils/case.js'

function MedicalRecordGenerator({ structuredCase, onGenerated }) {
  const [isGenerating, setIsGenerating] = useState(false)
  const [medicalRecord, setMedicalRecord] = useState('')
  const [patientInfo, setPatientInfo] = useState({
    name: '',
    gender: '',
    age: ''
  })
  const [doctorInfo, setDoctorInfo] = useState({
    name: '',
    department: ''
  })

  const handleGenerate = async () => {
    try {
      setIsGenerating(true)
      const result = await caseManager.generateMedicalRecord(
        structuredCase,
        patientInfo,
        doctorInfo
      )
      setMedicalRecord(result)
      onGenerated(result)
    } catch (error) {
      console.error('ç”Ÿæˆå¤±è´¥:', error)
      alert('ç”Ÿæˆå¤±è´¥')
    } finally {
      setIsGenerating(false)
    }
  }

  const handleExport = async () => {
    try {
      await caseManager.exportDocument(
        medicalRecord,
        patientInfo,
        doctorInfo
      )
      alert('æ–‡æ¡£å¯¼å‡ºæˆåŠŸ')
    } catch (error) {
      console.error('å¯¼å‡ºå¤±è´¥:', error)
      alert('å¯¼å‡ºå¤±è´¥')
    }
  }

  return (
    <div className="medical-record-generator">
      <div className="patient-info">
        <h3>æ‚£è€…ä¿¡æ¯</h3>
        <div className="field">
          <label>å§“åï¼š</label>
          <input 
            type="text"
            value={patientInfo.name}
            onChange={(e) => setPatientInfo({...patientInfo, name: e.target.value})}
          />
        </div>
        <div className="field">
          <label>æ€§åˆ«ï¼š</label>
          <select 
            value={patientInfo.gender}
            onChange={(e) => setPatientInfo({...patientInfo, gender: e.target.value})}
          >
            <option value="">è¯·é€‰æ‹©</option>
            <option value="ç”·">ç”·</option>
            <option value="å¥³">å¥³</option>
          </select>
        </div>
        <div className="field">
          <label>å¹´é¾„ï¼š</label>
          <input 
            type="number"
            value={patientInfo.age}
            onChange={(e) => setPatientInfo({...patientInfo, age: e.target.value})}
          />
        </div>
      </div>

      <div className="doctor-info">
        <h3>åŒ»ç”Ÿä¿¡æ¯</h3>
        <div className="field">
          <label>å§“åï¼š</label>
          <input 
            type="text"
            value={doctorInfo.name}
            onChange={(e) => setDoctorInfo({...doctorInfo, name: e.target.value})}
          />
        </div>
        <div className="field">
          <label>ç§‘å®¤ï¼š</label>
          <input 
            type="text"
            value={doctorInfo.department}
            onChange={(e) => setDoctorInfo({...doctorInfo, department: e.target.value})}
          />
        </div>
      </div>

      <div className="generate-controls">
        <button 
          onClick={handleGenerate}
          disabled={!structuredCase || isGenerating}
        >
          {isGenerating ? 'ç”Ÿæˆä¸­...' : 'ç”Ÿæˆç—…å†'}
        </button>
      </div>

      {medicalRecord && (
        <div className="medical-record-result">
          <h3>ç—…å†æ–‡æœ¬</h3>
          <textarea 
            value={medicalRecord}
            onChange={(e) => setMedicalRecord(e.target.value)}
            rows={20}
          />
          <button onClick={handleExport}>å¯¼å‡º Word æ–‡æ¡£</button>
        </div>
      )}
    </div>
  )
}

export default MedicalRecordGenerator
```

### ä¸»é¡µé¢ç»„ä»¶

```jsx
// pages/Home.jsx
import React, { useState } from 'react'
import Recorder from '../components/Recorder.jsx'
import CaseStructure from '../components/CaseStructure.jsx'
import MedicalRecordGenerator from '../components/MedicalRecordGenerator.jsx'

function Home() {
  const [transcript, setTranscript] = useState('')
  const [structuredCase, setStructuredCase] = useState(null)
  const [medicalRecord, setMedicalRecord] = useState('')

  return (
    <div className="home">
      <h1>è¯­éŸ³è½¬ç—…ä¾‹åŠ©æ‰‹</h1>
      
      <Recorder onTranscript={setTranscript} />
      
      {transcript && (
        <div className="transcript-section">
          <h2>è½¬å½•æ–‡æœ¬</h2>
          <textarea 
            value={transcript}
            onChange={(e) => setTranscript(e.target.value)}
            rows={10}
          />
          
          <CaseStructure 
            transcript={transcript}
            onStructured={setStructuredCase}
          />
        </div>
      )}
      
      {structuredCase && (
        <div className="structure-section">
          <MedicalRecordGenerator 
            structuredCase={structuredCase}
            onGenerated={setMedicalRecord}
          />
        </div>
      )}
    </div>
  )
}

export default Home
```

---

## ğŸ¨ æ ·å¼ç¤ºä¾‹

```css
/* styles/App.css */
.home {
  max-width: 1200px;
  margin: 0 auto;
  padding: 20px;
}

.recorder {
  margin: 20px 0;
  padding: 20px;
  border: 1px solid #ddd;
  border-radius: 8px;
}

.recording-indicator {
  color: #ff4444;
  animation: pulse 1.5s infinite;
}

.transcribing-indicator {
  color: #4CAF50;
}

@keyframes pulse {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.5; }
}

.recording-controls {
  margin: 20px 0;
}

.start-button {
  background: #4CAF50;
  color: white;
  padding: 10px 20px;
  border: none;
  border-radius: 4px;
  cursor: pointer;
}

.stop-button {
  background: #ff4444;
  color: white;
  padding: 10px 20px;
  border: none;
  border-radius: 4px;
  cursor: pointer;
}

.case-structure {
  margin: 20px 0;
  padding: 20px;
  border: 1px solid #ddd;
  border-radius: 8px;
}

.structured-result {
  margin-top: 20px;
}

.field {
  margin: 10px 0;
}

.field label {
  font-weight: bold;
  margin-right: 10px;
}

.medical-record-generator {
  margin: 20px 0;
  padding: 20px;
  border: 1px solid #ddd;
  border-radius: 8px;
}

.patient-info,
.doctor-info {
  margin: 20px 0;
}

.field input,
.field select {
  padding: 8px;
  border: 1px solid #ddd;
  border-radius: 4px;
}

textarea {
  width: 100%;
  padding: 10px;
  border: 1px solid #ddd;
  border-radius: 4px;
  font-family: inherit;
}

button {
  padding: 10px 20px;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  margin-right: 10px;
}

button:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}
```

---

## ğŸ“ å®Œæ•´å·¥ä½œæµç¨‹ç¤ºä¾‹

```javascript
// utils/workflow.js
import recorder from './recorder.js'
import caseManager from './case.js'

class Workflow {
  async processMedicalCase(patientInfo, doctorInfo) {
    try {
      // 1. å½•éŸ³
      await recorder.init()
      recorder.start()
      
      await new Promise(resolve => setTimeout(resolve, 60000))
      
      const audioBlob = await recorder.stop()
      
      // 2. è½¬å½•
      const transcript = await recorder.transcribe(audioBlob)
      
      // 3. ç»“æ„åŒ–
      const structuredCase = await caseManager.structureCase(transcript, true)
      
      // 4. ç”Ÿæˆç—…å†
      const medicalRecord = await caseManager.generateMedicalRecord(
        structuredCase,
        patientInfo,
        doctorInfo
      )
      
      // 5. å¯¼å‡ºæ–‡æ¡£
      await caseManager.exportDocument(
        medicalRecord,
        patientInfo,
        doctorInfo
      )
      
      // 6. ä¿å­˜ç—…ä¾‹
      const caseData = {
        patient_info: patientInfo,
        doctor_info: doctorInfo,
        transcript,
        structured_case: structuredCase,
        medical_record: medicalRecord,
        created_at: new Date().toISOString()
      }
      const caseId = await caseManager.saveCase(caseData)
      
      return {
        transcript,
        structuredCase,
        medicalRecord,
        caseId
      }
    } catch (error) {
      console.error('å¤„ç†å¤±è´¥:', error)
      throw error
    }
  }
}

export default new Workflow()
```

---

## âš ï¸ æ³¨æ„äº‹é¡¹

### 1. HTTPS è¦æ±‚

ç°ä»£æµè§ˆå™¨è¦æ±‚ä½¿ç”¨ HTTPS æ‰èƒ½è®¿é—®éº¦å…‹é£ã€‚åœ¨ç”Ÿäº§ç¯å¢ƒä¸­ï¼Œå¿…é¡»ä½¿ç”¨ HTTPSã€‚

### 2. æƒé™è¯·æ±‚

é¦–æ¬¡ä½¿ç”¨å½•éŸ³åŠŸèƒ½æ—¶ï¼Œæµè§ˆå™¨ä¼šè¯·æ±‚éº¦å…‹é£æƒé™ã€‚ç”¨æˆ·å¿…é¡»æˆäºˆæƒé™æ‰èƒ½ä½¿ç”¨ã€‚

### 3. é”™è¯¯å¤„ç†

æ‰€æœ‰ API è°ƒç”¨éƒ½åº”è¯¥åŒ…å«é”™è¯¯å¤„ç†ï¼š

```javascript
try {
  const result = await caseManager.structureCase(transcript)
} catch (error) {
  console.error('é”™è¯¯:', error)
  alert('æ“ä½œå¤±è´¥')
}
```

### 4. åŠ è½½çŠ¶æ€

åœ¨å¼‚æ­¥æ“ä½œæ—¶æ˜¾ç¤ºåŠ è½½çŠ¶æ€ï¼š

```javascript
const [isLoading, setIsLoading] = useState(false)

const handleAction = async () => {
  try {
    setIsLoading(true)
    await someAsyncOperation()
  } finally {
    setIsLoading(false)
  }
}
```

---

## ğŸš€ éƒ¨ç½²åˆ°ç”Ÿäº§ç¯å¢ƒ

### 1. ä¿®æ”¹ API åœ°å€

```javascript
// config/api.js
export const API_CONFIG = {
  baseURL: 'https://your-production-domain.com',
  timeout: 30000,
  retryCount: 3
}
```

### 2. é…ç½® HTTPS

ç¡®ä¿æ‚¨çš„ API æœåŠ¡ä½¿ç”¨ HTTPS åè®®ã€‚

### 3. æ„å»ºç”Ÿäº§ç‰ˆæœ¬

```bash
npm run build
```

### 4. éƒ¨ç½²åˆ°æœåŠ¡å™¨

å°†æ„å»ºåçš„æ–‡ä»¶éƒ¨ç½²åˆ°æ‚¨çš„ Web æœåŠ¡å™¨ã€‚

---

## ğŸ“ æŠ€æœ¯æ”¯æŒ

å¦‚æœ‰é—®é¢˜ï¼Œè¯·è”ç³»ï¼š
- **GitHub Issues**: https://github.com/your-repo/aisci/issues
- **Email**: support@example.com

---

## ğŸ“„ è®¸å¯è¯

MIT License
